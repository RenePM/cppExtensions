todo
fix logical not prototypes ~ => ! (OK)

fix BITWISE ASSIGNEMNT OPERATOR IMPLEMENTATION (OK)
	- Corrupts the statck
		- Possible a pointer corruption
		- object data type >= casted data type
- Copy latest ver of cppBitFlags to, debugTestConsole prj (OK)
- Implement cppBitFlags in debugTestConsole prj (PENDING)
-------------------------------------------



















-----------------------------------------------------------
    /*
        Function used to set bits (specified by flag) in thisFlag, to specified state
        INPUT :
            flag_       : bit mask specifying bits to set to specified state
            reservMask_ : bit mask specifying the reserved bit, hence DONT TOUCH bits "READ ONLY"

        OUTPUT :

        RETURN :
            T: new value of thisFlag
    */
    T   configBits(const TdataType flag_, const TdataType reservMask_)
    {
        // Clear all non reserved bits
        thisFlag_ &= reservMask_;

        // Set the specifed bits and return result
        return (thisFlag_ |= flag_);
    }


------------------------------
0x55, 0x19 ,0xA6

0001 1100 0x1D /thisFlag
X1X1 01X1 0x55, 0xA2 /setMask(!), reservMask(X)
0101 0101 0x55 (OK)

---------------------------------------------------

class cppEnumBitFlag
{

private:
    T   thisFlag_; // keep trak of thisFlags value

public:
    
    /*
        Def. Constructor, ensures that the class can be initialized
    */
    cppEnumBitFlag()
    {
        thisFlag_ = 0;
        return;
    }
    
    cppEnumBitFlag(const cppEnumBitFlag<T, TdataType>& flag_)
    {
        // Is this self assignemnt or object?
        if (thisFlag_ == flag_.thisFlag_)
        {
            //Y->Forced exit nothing to assign
            return;
        }

        //Assume N-> Update thisFlag
        thisFlag_ = flag_.thisFlag_;
        return;
    }

    cppEnumBitFlag(const T flag_)
    {
        // Is this self assignemnt?
        if (this->thisFlag_ == flag_)
        {
            //Y->Forced exit nothing to assign
            return;
        }

        //Assume N->Update thisFlag and return
        thisFlag_ = flag_;
        return;
    }

    cppEnumBitFlag(const TdataType flag_)
    {
        thisFlag_ = (T)flag_;
        return;
    }

    // Get function
    /*
        Function used to get thisFlag
        INPUT:

        OUTPUT:

        RETURN:
            T: The value of thisFlag
    */
    T get()
    {
        return thisFlag_;
    }


    // ASSIGNMENT OPERATOR OVERLOADS
    //**cppEnumBitFlag& operator= (const )
    cppEnumBitFlag& operator= (const cppEnumBitFlag<T, TdataType> flag_)
    {
        // Is this self assignemnt or object?
        if (thisFlag_ == flag_.thisFlag_)
        {
            //Y->Just forced exit nothing to assign
            // Return ref to thisObject
            return *this;
        }

        //Assume N-> Update thisFlag and return result
        thisFlag_ = flag_.thisFlag_;
        // Return ref to thisObject
        return *this;
    }
    
    cppEnumBitFlag& operator= (const T flag_) 
    { 
        // Is this self assignemnt?
        if (this->thisFlag_ == flag_)
        {
            //Y->forced exit nothing to assign
            // Return ref to thisObject
            return *this;
        }

        //Assume N-> Update thisFlag and return result
        thisFlag_ = flag_;
        // Return ref to thisObject
        return *this;
    }

    cppEnumBitFlag& operator= (const TdataType flag_) 
    { 
        // Is this self assignemnt?
        if (this->thisFlag_ == (T)flag_)
        {
            //Y->Just forced exit nothing to assign
            // Return ref to thisObject
            return *this;
        }

        // Update thisFlag
        thisFlag_ = (T)flag_;
        // Return ref to thisObject
        return *this;
    }

    // COMPARISON OPERATOR
    const bool operator== (const T flag_) { return (bool)((TdataType)thisFlag_ == (TdataType)flag_); } // EQUAL TO, thisFlag == flag
    const bool operator== (const TdataType flag_) { return (bool)((TdataType)thisFlag_ == flag_); } // EQUAL TO, thisFlag == flag
    const bool operator!= (const T flag_) { return (bool)((TdataType)thisFlag_ != (TdataType)flag_); } // NOT EQUAL TO, thisFlag != flag
    const bool operator!= (const TdataType flag_) { return (bool)((TdataType)thisFlag_ != flag_); } // NOT EQUAL TO, thisFlag != flag

    // LOGICAL OPERATOR OVERLOADS
    bool operator! () { return (bool)(!(TdataType)thisFlag_); } // LOGICAL NEGATION (NOT)
    bool operator&& (const T flag_) { return (bool)((TdataType)thisFlag_ && (TdataType)flag_); } // LOGICAL AND
    bool operator&& (const TdataType flag_) { return (bool)((TdataType)thisFlag_ && flag_); } // LOGICAL AND
    bool operator|| (const T flag_) { return (bool)((TdataType)thisFlag_ || (TdataType)flag_); } // LOGICAL OR
    bool operator|| (const TdataType flag_) { return (bool)((TdataType)thisFlag_ || flag_); } // LOGICAL OR
                        
    // BITWISE OPERATORS OVERLOADS
    T operator~() { return (T)(~(TdataType)thisFlag_); } // BITWISE NOT/NEGATE (INVERT/FLIP BITS)
    T operator| (const T flag_) { return (T)((TdataType)thisFlag_ | (TdataType)flag_); } // BITWISE OR
    T operator| (const TdataType flag_) { return (T)((TdataType)thisFlag_ | flag_); } // BITWISE OR
    T operator& (const T flag_) { return (T)((TdataType)thisFlag_ & (TdataType)flag_); } // BITWISE AND
    T operator& (const TdataType flag_) { return (T)((TdataType)thisFlag_ & flag_); } // BITWISE AND
    T operator^ (const T flag_) { return (T)((TdataType)thisFlag_ ^ (TdataType)flag_); } // BITWISE XOR (BITWISE UNEQUAL DETECTOR), 1&1=0, 1&0=1, 0&1=1, 0&0=1
    T operator^ (const TdataType flag_) { return (T)((TdataType)thisFlag_ ^ flag_); } // BITWISE XOR (BITWISE UNEQUAL DETECTOR), 1&1=0, 1&0=1, 0&1=1, 0&0=1

    //BITWISE ASSIGNEMNT OPERATOR OVERLOADS
    T& operator|= (const T flag_) { return (T&)((TdataType&)thisFlag_ |= (TdataType)flag_); } // BITWISE OR ASSIGNEMT, thisFlag |= flag = thisFlag = (thisFlag | flag)
    T& operator|= (const TdataType flag_) { return (T&)((TdataType&)thisFlag_ |= flag_); } // BITWISE OR ASSIGNEMT, thisFlag |= flag = thisFlag = (thisFlag | flag)
    T& operator&= (const T flag_) { return (T&)((TdataType&)thisFlag_ &= (TdataType)flag_); } // BITWISE AND ASSIGNEMT, thisFlag &= flag = thisFlag = (thisFlag & flag)
    T& operator&= (const TdataType flag_) { return (T&)((TdataType&)thisFlag_ &= flag_); } // BITWISE AND ASSIGNEMT, thisFlag &= flag = thisFlag = (thisFlag & flag)
    T& operator^= (const T flag_) { return (T&)((TdataType&)thisFlag_ ^= (TdataType)flag_); } // BITWISE XOR ASSIGNEMT, thisFlag ^= flag = thisFlag = (thisFlag ^ flag)
    T& operator^= (const TdataType flag_) { return (T&)((TdataType&)thisFlag_ ^= flag_); } // BITWISE XOR ASSIGNEMT, thisFlag ^= flag = thisFlag = (thisFlag ^ flag)

    // BIT MANIPULATION
    /*
        Function used to set bits (specified by flag_) in thisFlag
        INPUT:
            flag_: flag containing bit mask specifing bits to set
        OUTPUT:

        RETURN:
            T: the new value of thisFlag
    */
    T   setBits(const T flag_)
    {                
        return (thisFlag_ |= flag_);
    }
    T   setBits(const TdataType flag_)
    {
        return (thisFlag_ |= flag_);
    }

    /*
        Function used to set a specific bit (specified by bitIx) in thisFlag
        INPUT:
            bitIx_: bit ix of bit to set

        OUTPUT:

        RETURN:
            T: the new value of thisFlag
    */
    T   setBit(const TdataType bitIx_ = 0)
    {
        return (thisFlag_ |= ((T)(1 << bitIx_)));
    }

    /*
        Function used to clear bits (specified by flag_) in thisFlag
        INPUT:
            flag_: flag containing bit mask specifing bits to clear

        OUTPUT:

        RETURN:
            T: new value of thisFlag
    */
    T   clearBits(const T flag_)
    {
        return (thisFlag_ &= ~flag_);
    }
    T   clearBits(const TdataType flag_)
    {
        return (thisFlag_ &= ~(T)flag_);
    }

    /*
        Function used to clear a specific bit (specified by bitIx) in thisFlag
        INPUT :
            bitIx_: bit ix of bit to clear

        OUTPUT :

        RETURN :
            T: new value of thisFlag
    */
    T   clearBit(const TdataType bitIx_ = 0)
    {
        return (thisFlag_ &= (~(T)(1 << bitIx_)));
    }

    /*
        Function used to toggle bits (specified by flag) in thisFlag
        INPUT :
            flag_: flag containing bit mask specifying bits to toggle

        OUTPUT :

        RETURN :
            T: new value of thisFlag 
    */
    T   toggleBits(const T flag_)
    {
        return (thisFlag_ ^= flag_);
    }
    T   toggleBits(const TdataType flag_)
    {
        return (thisFlag_ ^= (T)flag_);
    }

    /*
        Function used to toggle a specific bit (specified by bitIx) in thisFlag
        INPUT :
            bitIx_: bit ix of bit to toggle
        OUTPUT :

        RETURN :
            T: new value of thisFlag
            
    */
    T   toggleBit(const TdataType bitIx_ = 0)
    {
        return (thisFlag_ ^= ((T)(1 << bitIx_)));
    }

    /*
        Function used to set bits (specified by flag) in thisFlag, to specified state
        INPUT :
            flag_       : flag containing bit mask specifying bits to set to specified state
            reservMask_ : bit mask specifying the reserved bit, hence DONT TOUCH bits "READ ONLY"

        OUTPUT :

        RETURN :
            T: new value of thisFlag
    */
    T   configBits(const T flag_, const T reservMask_)
    {
        // Clear all non reserved bits
        thisFlag_ &= reservMask_;

        // Set the specifed bits and return result
        return (thisFlag_ |= flag_);
    }
    T   configBits(const TdataType flag_, const TdataType reservMask_)
    {
        // Clear all non reserved bits
        thisFlag_ &= (T)reservMask_;

        // Set the specifed bits and return result
        return (thisFlag_ |= (T)flag_);
    }

    // BIT COMPARE TESTS
    /*
        Function used to check if one or more specific bit flag is set (BIT ON TEST)
        INPUT:
            flag_: flag containing bit mask specifying bits to check

        OUTPUT

        RETURN:
            bool: T = Bit is set(1), F = bit is cleared(0) 
    */
    bool    isSet(const T flag_)
    {
        // Return result of BITWISE AND
        return (bool)(thisFlag_ & flag_);
    }
    bool    isSetHex(const TdataType flag_)
    {
        // Return result of BITWISE AND
        return (bool)((TdataType)thisFlag_ & flag_);
    }

    /*
        Function used to check if a specific bit is set (BIT n ON TEST)
        INPUT:
            bitIx_: bit ix for bit to check

        OUTPUT:

        RETURN:
            bool: T = Bit is set(1), F = bit is cleared(0)
    */
    bool    isSet(const TdataType bitIx_ = 0)
    {
        // Return result of BITWISE AND
        return (bool)((TdataType)thisFlag_ & ((TdataType)(1 << bitIx_)));
    }


    /*
        Function used to check if one or more specific bit flag is cleared (BIT OFF TEST)
        INPUT:
            flag_: flag containing bit mask specifying bits to check

        OUTPUT

        RETURN:
            bool: T = Bit is cleared(0), F = bit is set(1)
    */
    bool    isClear(const T flag_)
    {
        // Return result of BITWISE AND        
        return (bool)(thisFlag_ & ~flag_);
    }
    bool    isClearHex(const TdataType flag_)
    {
        // Return result of BITWISE AND, thisFlag is casted as TdataTYpe because there is no operator overload for a & ~b        
        return (bool)((TdataType)thisFlag_ & ~flag_);
    }

    /*
        Function used to check if a specific bit is cleared (BIT n OFF TEST)
        INPUT:
            bitIx_: bit ix for bit to check

        OUTPUT:

        RETURN:
            bool: T = Bit is cleared(0), F = Bit is set(1) 
    */
    bool    isClear(const TdataType bitIx_ = 0)
    {
        // Return result of BITWISE AND, 
        /*
            thisFlag is casted as TdataTYpe because operator overload dont work inside class
            where the Operator is overloaded ??
        */
        return (bool)((TdataType)thisFlag_ & (~(TdataType)(1 << bitIx_)));
    }
  
};